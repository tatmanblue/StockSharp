<?xml version="1.0" encoding="utf-8"?>
<topic id="8b9125ee-9d74-444f-82d6-5dea51266fd4" revisionNumber="1">
  <developerWalkthroughDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>
      	<token>stocksharp</token> provides over 70 technical analysis indicators as standard. This allows not to create the necessary indicators from scratch, but to use finished ones. In addition, you can create your own indicators, taking existing ones as a basis, as shown in the 
      	<link xlink:href="ec4c3abe-3779-4a5f-899c-697b049254d4"/>.
      	section. All the base classes for working with indicators, as well as the indicators themselves, are located in the 
      	<codeEntityReference qualifyHint="true">N:StockSharp.Algo.Indicators</codeEntityReference> namespace. 
      </para>
    </introduction>
    <procedure>
      <title>Connecting the indicator to the robot</title>
      <steps class="ordered">
        <step>
          <content>
            <para>At the very beginning, you need to create an indicator. The indicator is created, just like a regular .NET object:</para>
			<code language="C#"><![CDATA[var longSma = new SimpleMovingAverage { Length = 80 };]]></code>
          </content>
        </step>
        <step>
          <content>
            <para>Next, you need to fill it with data. For example, this could be the candle closing price:</para>
            <code language="C#"><![CDATA[foreach (var candle in candles)
	longSma.Process(candle);]]></code>
			<para>
			The indicator accepts an 
			<codeEntityReference>T:StockSharp.Algo.Indicators.IIndicatorValue</codeEntityReference>. 
			at the input. Some of the indicators operate with a prime number, such as 
			<codeEntityReference>T:StockSharp.Algo.Indicators.SimpleMovingAverage</codeEntityReference>.
			Others require a full candle, such as <codeEntityReference>T:StockSharp.Algo.Indicators.MedianPrice</codeEntityReference>.
			Therefore, input values must be cast to either 
			<codeEntityReference>T:StockSharp.Algo.Indicators.DecimalIndicatorValue</codeEntityReference>
			or <codeEntityReference>T:StockSharp.Algo.Indicators.CandleIndicatorValue</codeEntityReference>. 
			The resulting indicator value works according to the same rules as the input value.
			</para>
          </content>
        </step>
        <step>
          <content>
            <para>The resulting and the input value of the indicator have the 
            <codeEntityReference qualifyHint="true">P:StockSharp.Algo.Indicators.IIndicatorValue.IsFinal</codeEntityReference>, 
            property, which indicates that the value is final and the indicator will not change at a given point in time. For example, the 
            <codeEntityReference>T:StockSharp.Algo.Indicators.SimpleMovingAverage</codeEntityReference>
            indicator is generated by the candle closing price, but at the current moment the final candle closing price is unknown and is changing. In this case, the resulting 
            <codeEntityReference qualifyHint="true">P:StockSharp.Algo.Indicators.IIndicatorValue.IsFinal</codeEntityReference>
            value will be 'false'. If the finished candle is passed to the indicator, then the input and resulting values of 
            <codeEntityReference qualifyHint="true">P:StockSharp.Algo.Indicators.IIndicatorValue.IsFinal</codeEntityReference> will be 'true'.</para>
			
          </content>
        </step>
        <step>
          <content>
            <para>To get the current indicator value, the <codeEntityReference qualifyHint="false" autoUpgrade="true">M:StockSharp.Algo.Indicators.IIndicatorValue.GetValue``1</codeEntityReference> method is used:</para>
			<code language="C#"><![CDATA[
// calculate the new position relative to each other
var isShortLessThenLong = ShortSma.GetCurrentValue() < LongSma.GetCurrentValue();

// if there was an intersection
if (_isShortLessThenLong != isShortLessThenLong)
{
	// if short is less than long, then sale, otherwise, purchase.
	var direction = isShortLessThenLong ? Sides.Sell : Sides.Buy;

	// register the order
	var volume = Position == 0 ? Volume : Position.Abs().Min(Volume) * 2;
	var price = candle.ClosePrice + ((direction == Sides.Buy ? Security.PriceStep : -Security.PriceStep) ?? 1);
    RegisterOrder(this.CreateOrder(direction, price, volume));

	// remember the current position relative to each other
	_isShortLessThenLong = isShortLessThenLong;
}]]></code>
          </content>
        </step>
                <step>
          <content>
          <para>All indicators have a 
          <codeEntityReference qualifyHint="true">P:StockSharp.Algo.Indicators.BaseIndicator.IsFormed</codeEntityReference>,
          property, which indicates whether the indicator is ready for use. For example, the 
          <codeEntityReference>T:StockSharp.Algo.Indicators.SimpleMovingAverage</codeEntityReference> 
          indicator has a period, and until the indicator processes the number of candles equal to the indicator period, the indicator will be considered not ready for use. And the 
          <codeEntityReference qualifyHint="true">P:StockSharp.Algo.Indicators.BaseIndicator.IsFormed</codeEntityReference> property will be 'false'.</para>
          </content>
        </step>
      </steps>
    </procedure>
    <relatedTopics>
    </relatedTopics>
  </developerWalkthroughDocument>
</topic>